<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>proyh</title>
  <subtitle>不要乱了计划</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-11T08:39:17.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>观察者设计模式</title>
    <link href="http://yoursite.com/2016/08/09/%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/08/09/观察者设计模式/</id>
    <published>2016-08-09T03:46:16.000Z</published>
    <updated>2016-08-11T08:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<h4 id="模式中的角色"><a href="#模式中的角色" class="headerlink" title="模式中的角色"></a>模式中的角色</h4><ol>
<li><p>抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p>
</li>
<li><p>具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</p>
</li>
<li><p>抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p>
</li>
<li><p>具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p>
</li>
</ol>
<h3 id="观察者模式的java代码"><a href="#观察者模式的java代码" class="headerlink" title="观察者模式的java代码"></a>观察者模式的java代码</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package observer;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  观察者模式的抽象主题</div><div class="line"> */</div><div class="line">public abstract class Subject &#123;</div><div class="line">    private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();</div><div class="line"></div><div class="line">    public void attach(Observer observer) &#123;</div><div class="line">        observers.add(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void detach(Observer observer) &#123;</div><div class="line">        observers.remove(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Notify() &#123;</div><div class="line">        for (Observer o : observers) &#123;</div><div class="line">            o.update();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package observer;</div><div class="line">/**</div><div class="line"> * 抽象观察者类，为所有具体观察者定义一个接口，在得到通知时更新自己</div><div class="line"> */</div><div class="line">public  abstract class Observer &#123;</div><div class="line">    public abstract void update();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package observer;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 具体观察者或具体通知者，将有关状态存入具体观察者对象； 在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。</div><div class="line"> */</div><div class="line">public class ConcreteSubject extends Subject &#123;</div><div class="line"></div><div class="line">    private String subjectState;</div><div class="line"></div><div class="line">    public String getSubjectState() &#123;</div><div class="line">        return subjectState;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSubjectState(String subjectState) &#123;</div><div class="line">        this.subjectState = subjectState;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package observer;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 具体观察者，实现抽象观察者角色所要求的更新接口，已是本身状态与主题状态相协调</div><div class="line"> */</div><div class="line">public class ConcreteObserver extends Observer &#123;</div><div class="line">    private String observerState;</div><div class="line">    private String name;</div><div class="line">    private ConcreteSubject subject;</div><div class="line"></div><div class="line">    public ConcreteObserver(ConcreteSubject subject, String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.subject = subject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void update() &#123;</div><div class="line"></div><div class="line">        observerState = subject.getSubjectState();</div><div class="line">        System.out.println(&quot;The observer&apos;s state of &quot; + name + &quot; is &quot; + observerState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ConcreteSubject getSubject() &#123;</div><div class="line">        return subject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSubject(ConcreteSubject subject) &#123;</div><div class="line">        this.subject = subject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package observer;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 具体观察者，实现抽象观察者角色所要求的更新接口，已是本身状态与主题状态相协调   可以有多个</div><div class="line"> */</div><div class="line">public class ConcreteNewPage extends Observer &#123;</div><div class="line">    private String observerState;</div><div class="line">    private String name;</div><div class="line">    private ConcreteSubject subject;</div><div class="line"></div><div class="line">    public ConcreteNewPage(ConcreteSubject subject, String name) &#123;</div><div class="line"></div><div class="line">        this.name = name;</div><div class="line">        this.subject = subject;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void update() &#123;</div><div class="line"></div><div class="line">        observerState = subject.getSubjectState();</div><div class="line">        System.out.println(this.getClass().getName() + name + &quot; is &quot; + observerState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ConcreteSubject getSubject() &#123;</div><div class="line">        return subject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSubject(ConcreteSubject subject) &#123;</div><div class="line">        this.subject = subject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package observer;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 具体的测试</div><div class="line"> */</div><div class="line">public class TestObserver &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 具体主题角色通常用具体自来来实现</div><div class="line">        ConcreteSubject subject = new ConcreteSubject();</div><div class="line">        </div><div class="line">        subject.setSubjectState(&quot;今日头条&quot;);</div><div class="line"></div><div class="line">        subject.attach(new ConcreteObserver(subject, &quot;Observer A&quot;));</div><div class="line">        subject.attach(new ConcreteObserver(subject, &quot;Observer B&quot;));</div><div class="line">        subject.attach(new ConcreteObserver(subject, &quot;Observer C&quot;));</div><div class="line">        subject.attach(new ConcreteNewPage(subject, &quot;newPage is big font&quot;));</div><div class="line"></div><div class="line">        subject.Notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h5 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The observer&apos;s state of Observer A is 今日头条</div><div class="line">The observer&apos;s state of Observer B is 今日头条</div><div class="line">The observer&apos;s state of Observer C is 今日头条</div><div class="line">observer.ConcreteNewPagenewPage is big font is 今日头条</div></pre></td></tr></table></figure>
<hr>
<h4 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><p>当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。</p>
</li>
<li><p>一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式 观察者" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>高并发static变量的缺陷</title>
    <link href="http://yoursite.com/2016/08/09/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2016/08/09/高并发/</id>
    <published>2016-08-09T03:32:15.000Z</published>
    <updated>2016-08-09T04:03:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。也就是被static修饰的变量在内存中只有一份内存地址。<br>在高并发中被static修饰的变量很容易出现脏读的情况。<br>比如：</p>
<p><code>public static SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</code></p>
<p>这样的代码在高并发的情况下会出现以下问题<br>当线程A从客户端访问服务器将数据还没返回到客户端的时候，线程B同时也将数据返回到客户端，如此一来由于static只有一块内存导致线程A的数据就会被线程B的数据所替换导致线程A拿到的数据是脏数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。也就是被static修饰的变量在内存中只有一份内存地址。
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>java excel导入导出</title>
    <link href="http://yoursite.com/2016/08/02/java%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2016/08/02/java导入导出/</id>
    <published>2016-08-01T16:47:54.000Z</published>
    <updated>2016-08-09T03:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>导入方法</p>
<pre><code>    WritableWorkbook book = Workbook.createWorkbook(new File(&quot;F:/test.xls&quot;));
    // 生成名为“第一页”的工作表，参数0表示这是第一页
    WritableSheet sheet = book.createSheet(&quot;第一页&quot; , 0 );
    // 在Label对象的构造子中指名单元格位置是第一列第一行(0,0)
    // 以及单元格内容为test

    Label label =null;
    // 写入数据并关闭文件 
    book.write();
    book.close();
    int i=0;
    sheet.addCell(new Label( 0 , 0 , &quot;用户ID&quot; ));
        // 将定义好的单元格添加到工作表中
      label= new Label( 0 , i , userId );
      sheet.addCell(label);
         /**/ 
        /*
         * 生成一个保存数字的单元格 必须使用Number的完整包路径，否则有语法歧义 单元格位置是第二列，第一行，值为789.123
        */
         jxl.write.Number number = new jxl.write.Number( 1 , 0 , 555.12541 );
            sheet.addCell(number);

}
</code></pre><p>读取方法</p>
<pre><code>        try {
            Workbook rwb=Workbook.getWorkbook(new File(&quot;F:/test.xls&quot;));
            Sheet rs=rwb.getSheet(0);//或者rwb.getSheet(0)
            int clos=rs.getColumns();//得到所有的列
            int rows=rs.getRows();//得到所有的行

            for (int i = 1; i &lt; rows; i++) {
                for (int j = 0; j &lt; clos; j++) {
                    //第一个是列数，第二个是行数
                    String userid=rs.getCell(j++, i).getContents();//默认最左边编号也算一列 所以这里得j++
                    String balance=rs.getCell(j++, i).getContents();
                    String availableAmount=rs.getCell(j++, i).getContents();
                    String freezeAmount=rs.getCell(j++, i).getContents();

                    System.out.println(&quot;用户id:&quot;+userid+&quot;\t账户余额:&quot;+balance+&quot;\t可用余额:&quot;+availableAmount+&quot;\t冻结余额:&quot;+freezeAmount);
                }
            }
}catch(Exception e){}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导入方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    WritableWorkbook book = Workbook.createWorkbook(new File(&amp;quot;F:/test.xls&amp;quot;));
    // 生成名为“第一页”的工作表，参数0表示这是第
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java导入 excel导入" scheme="http://yoursite.com/tags/java%E5%AF%BC%E5%85%A5-excel%E5%AF%BC%E5%85%A5/"/>
    
  </entry>
  
</feed>
