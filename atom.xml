<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>proyh</title>
  <subtitle>不要乱了计划</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-09T06:37:56.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>观察者设计模式</title>
    <link href="http://yoursite.com/2016/08/09/%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/08/09/观察者设计模式/</id>
    <published>2016-08-09T03:46:16.000Z</published>
    <updated>2016-08-09T06:37:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>####定义<br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<p>####模式中的角色</p>
<p>　　1. 抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p>
<p>　　2. 具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</p>
<p>　　3. 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p>
<p>　　4. 具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####定义&lt;br&gt;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。&lt;/p&gt;
&lt;p&gt;####模式中的角色&lt;/p&gt;
&lt;p&gt;　　1. 抽象主题（Subject）：它把所有观
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式 观察者" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>高并发static变量的缺陷</title>
    <link href="http://yoursite.com/2016/08/09/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2016/08/09/高并发/</id>
    <published>2016-08-09T03:32:15.000Z</published>
    <updated>2016-08-09T04:03:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。也就是被static修饰的变量在内存中只有一份内存地址。<br>在高并发中被static修饰的变量很容易出现脏读的情况。<br>比如：</p>
<p><code>public static SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</code></p>
<p>这样的代码在高并发的情况下会出现以下问题<br>当线程A从客户端访问服务器将数据还没返回到客户端的时候，线程B同时也将数据返回到客户端，如此一来由于static只有一块内存导致线程A的数据就会被线程B的数据所替换导致线程A拿到的数据是脏数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。也就是被static修饰的变量在内存中只有一份内存地址。
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>java excel导入导出</title>
    <link href="http://yoursite.com/2016/08/02/java%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2016/08/02/java导入导出/</id>
    <published>2016-08-01T16:47:54.000Z</published>
    <updated>2016-08-09T03:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>导入方法</p>
<pre><code>    WritableWorkbook book = Workbook.createWorkbook(new File(&quot;F:/test.xls&quot;));
    // 生成名为“第一页”的工作表，参数0表示这是第一页
    WritableSheet sheet = book.createSheet(&quot;第一页&quot; , 0 );
    // 在Label对象的构造子中指名单元格位置是第一列第一行(0,0)
    // 以及单元格内容为test

    Label label =null;
    // 写入数据并关闭文件 
    book.write();
    book.close();
    int i=0;
    sheet.addCell(new Label( 0 , 0 , &quot;用户ID&quot; ));
        // 将定义好的单元格添加到工作表中
      label= new Label( 0 , i , userId );
      sheet.addCell(label);
         /**/ 
        /*
         * 生成一个保存数字的单元格 必须使用Number的完整包路径，否则有语法歧义 单元格位置是第二列，第一行，值为789.123
        */
         jxl.write.Number number = new jxl.write.Number( 1 , 0 , 555.12541 );
            sheet.addCell(number);

}
</code></pre><p>读取方法</p>
<pre><code>        try {
            Workbook rwb=Workbook.getWorkbook(new File(&quot;F:/test.xls&quot;));
            Sheet rs=rwb.getSheet(0);//或者rwb.getSheet(0)
            int clos=rs.getColumns();//得到所有的列
            int rows=rs.getRows();//得到所有的行

            for (int i = 1; i &lt; rows; i++) {
                for (int j = 0; j &lt; clos; j++) {
                    //第一个是列数，第二个是行数
                    String userid=rs.getCell(j++, i).getContents();//默认最左边编号也算一列 所以这里得j++
                    String balance=rs.getCell(j++, i).getContents();
                    String availableAmount=rs.getCell(j++, i).getContents();
                    String freezeAmount=rs.getCell(j++, i).getContents();

                    System.out.println(&quot;用户id:&quot;+userid+&quot;\t账户余额:&quot;+balance+&quot;\t可用余额:&quot;+availableAmount+&quot;\t冻结余额:&quot;+freezeAmount);
                }
            }
}catch(Exception e){}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导入方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    WritableWorkbook book = Workbook.createWorkbook(new File(&amp;quot;F:/test.xls&amp;quot;));
    // 生成名为“第一页”的工作表，参数0表示这是第
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java导入 excel导入" scheme="http://yoursite.com/tags/java%E5%AF%BC%E5%85%A5-excel%E5%AF%BC%E5%85%A5/"/>
    
  </entry>
  
</feed>
